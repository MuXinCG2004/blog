---
title: LeetCode 1. 两数之和 - 三种解法详解
date: 2025-12-10
tags: [算法, LeetCode, 哈希表, Python]
lang: zh
---

两数之和是 LeetCode 的第一道题，也是面试中的高频题目。本文将介绍三种不同的解法，从暴力到最优。

## 题目描述

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出和为目标值的那两个整数，并返回它们的数组下标。

**示例：**

```
输入：nums = [2, 7, 11, 15], target = 9
输出：[0, 1]
解释：因为 nums[0] + nums[1] == 9，返回 [0, 1]
```

## 解法一：暴力枚举

最直观的方法是使用两层循环，遍历所有可能的数对。

```python
def twoSum(nums: list[int], target: int) -> list[int]:
    n = len(nums)
    for i in range(n):
        for j in range(i + 1, n):
            if nums[i] + nums[j] == target:
                return [i, j]
    return []
```

**复杂度分析：**
- 时间复杂度：$O(n^2)$，两层循环
- 空间复杂度：$O(1)$，只使用常数空间

## 解法二：哈希表（两次遍历）

我们可以用哈希表存储每个元素的索引，然后查找 `target - nums[i]` 是否存在。

```python
def twoSum(nums: list[int], target: int) -> list[int]:
    # 第一次遍历：建立哈希表
    hash_map = {}
    for i, num in enumerate(nums):
        hash_map[num] = i

    # 第二次遍历：查找配对
    for i, num in enumerate(nums):
        complement = target - num
        if complement in hash_map and hash_map[complement] != i:
            return [i, hash_map[complement]]

    return []
```

**复杂度分析：**
- 时间复杂度：$O(n)$，两次线性遍历
- 空间复杂度：$O(n)$，哈希表存储

## 解法三：哈希表（一次遍历）⭐ 最优解

我们可以在遍历的同时检查配对元素是否已经在哈希表中，这样只需要一次遍历。

```python
def twoSum(nums: list[int], target: int) -> list[int]:
    hash_map = {}

    for i, num in enumerate(nums):
        complement = target - num

        # 检查配对元素是否已存在
        if complement in hash_map:
            return [hash_map[complement], i]

        # 将当前元素加入哈希表
        hash_map[num] = i

    return []
```

**复杂度分析：**
- 时间复杂度：$O(n)$，只需一次遍历
- 空间复杂度：$O(n)$，哈希表存储

## 图解算法过程

以 `nums = [2, 7, 11, 15], target = 9` 为例：

| 步骤 | 当前元素 | 需要找的数 | 哈希表状态 | 结果 |
|:---:|:---:|:---:|:---|:---|
| 1 | 2 | 7 | `{2: 0}` | 未找到 |
| 2 | 7 | 2 | `{2: 0, 7: 1}` | 找到！返回 `[0, 1]` |

## 扩展思考

如果题目要求返回所有满足条件的数对呢？我们可以稍作修改：

```python
def twoSumAll(nums: list[int], target: int) -> list[list[int]]:
    hash_map = {}
    result = []

    for i, num in enumerate(nums):
        complement = target - num

        if complement in hash_map:
            for j in hash_map[complement]:
                result.append([j, i])

        # 使用列表存储相同值的所有索引
        if num not in hash_map:
            hash_map[num] = []
        hash_map[num].append(i)

    return result
```

## 总结

| 解法 | 时间复杂度 | 空间复杂度 | 特点 |
|:---|:---:|:---:|:---|
| 暴力枚举 | $O(n^2)$ | $O(1)$ | 简单直观，适合小数据 |
| 两次哈希 | $O(n)$ | $O(n)$ | 空间换时间 |
| 一次哈希 | $O(n)$ | $O(n)$ | 最优解，边遍历边查找 |

掌握哈希表的使用是解决此类「查找配对」问题的关键！
